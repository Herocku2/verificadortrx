{"ast":null,"code":"var _jsxFileName = \"/Volumes/DATOS/verificador/verificadortrx/frontend/src/context/UserContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext } from 'react';\nimport { getUserInfo } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst UserContext = /*#__PURE__*/createContext();\nexport const useUser = () => {\n  _s();\n  return useContext(UserContext);\n};\n_s(useUser, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const UserProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [wallet, setWallet] = useState(localStorage.getItem('wallet') || null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Cargar información del usuario cuando se establece la wallet\n  useEffect(() => {\n    const fetchUserData = async () => {\n      if (!wallet) {\n        setUser(null);\n        setLoading(false);\n        return;\n      }\n      setLoading(true);\n\n      // Crear un usuario por defecto en caso de que todo falle\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      try {\n        // Intentar obtener datos del usuario del backend\n        const userData = await getUserInfo(wallet);\n\n        // La función getUserInfo ya maneja los errores de red y devuelve datos en caché o por defecto\n        if (userData) {\n          setUser(userData);\n          localStorage.setItem('wallet', wallet);\n        } else {\n          console.warn('getUserInfo devolvió datos nulos o indefinidos');\n          setUser(defaultUser);\n        }\n      } catch (err) {\n        console.error('Error inesperado al cargar datos del usuario:', err);\n        setError('Error inesperado al cargar datos del usuario');\n\n        // Intentar recuperar datos del usuario del localStorage\n        const cachedUserData = localStorage.getItem(`user_${wallet}`);\n        if (cachedUserData) {\n          try {\n            setUser(JSON.parse(cachedUserData));\n          } catch (parseErr) {\n            console.error('Error al parsear datos en caché:', parseErr);\n            setUser(defaultUser);\n          }\n        } else {\n          setUser(defaultUser);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Ejecutar fetchUserData solo si hay wallet\n    if (wallet) {\n      fetchUserData();\n    } else {\n      // Si no hay wallet, asegurarse de que user sea null\n      setUser(null);\n      setLoading(false);\n    }\n  }, [wallet]);\n\n  // Función para actualizar la wallet del usuario\n  const updateWallet = newWallet => {\n    if (newWallet && newWallet.startsWith('T')) {\n      // Conectar nueva wallet\n      setWallet(newWallet);\n      localStorage.setItem('wallet', newWallet);\n      console.log(`Wallet conectada: ${newWallet}`);\n    } else if (newWallet === null) {\n      // Desconectar wallet\n      console.log('Desconectando wallet...');\n\n      // Limpiar estado\n      setWallet(null);\n      setUser(null);\n      setError(null);\n\n      // Limpiar localStorage\n      localStorage.removeItem('wallet');\n\n      // También podríamos limpiar otros datos relacionados con la wallet\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith('user_') || key.startsWith('p2p_user_'))) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => {\n        try {\n          localStorage.removeItem(key);\n        } catch (e) {\n          console.error(`Error al eliminar ${key} de localStorage:`, e);\n        }\n      });\n      console.log('Wallet desconectada correctamente');\n    }\n  };\n\n  // Función para actualizar los tokens del usuario después de una consulta\n  const updateTokens = newTokens => {\n    if (user) {\n      setUser({\n        ...user,\n        tokens_disponibles: newTokens\n      });\n    }\n  };\n\n  // Función para actualizar el plan del usuario después de un pago\n  const updatePlan = (newPlan, newTokens) => {\n    if (user) {\n      setUser({\n        ...user,\n        plan: newPlan,\n        tokens_disponibles: newTokens\n      });\n    }\n  };\n  const value = {\n    user,\n    wallet,\n    loading,\n    error,\n    updateWallet,\n    updateTokens,\n    updatePlan\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 148,\n    columnNumber: 10\n  }, this);\n};\n_s2(UserProvider, \"5mR3N4Z7PV0W4dJuGC6O03wV3nU=\");\n_c = UserProvider;\nvar _c;\n$RefreshReg$(_c, \"UserProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","getUserInfo","jsxDEV","_jsxDEV","UserContext","useUser","_s","UserProvider","children","_s2","user","setUser","wallet","setWallet","localStorage","getItem","loading","setLoading","error","setError","fetchUserData","defaultUser","usuario","username","substring","tokens_disponibles","plan","expira","userData","setItem","console","warn","err","cachedUserData","JSON","parse","parseErr","updateWallet","newWallet","startsWith","log","removeItem","keysToRemove","i","length","key","push","forEach","e","updateTokens","newTokens","updatePlan","newPlan","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Volumes/DATOS/verificador/verificadortrx/frontend/src/context/UserContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext } from 'react';\nimport { getUserInfo } from '../services/api';\n\nconst UserContext = createContext();\n\nexport const useUser = () => useContext(UserContext);\n\nexport const UserProvider = ({ children }) => {\n  const [user, setUser] = useState(null);\n  const [wallet, setWallet] = useState(localStorage.getItem('wallet') || null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Cargar información del usuario cuando se establece la wallet\n  useEffect(() => {\n    const fetchUserData = async () => {\n      if (!wallet) {\n        setUser(null);\n        setLoading(false);\n        return;\n      }\n\n      setLoading(true);\n      \n      // Crear un usuario por defecto en caso de que todo falle\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      \n      try {\n        // Intentar obtener datos del usuario del backend\n        const userData = await getUserInfo(wallet);\n        \n        // La función getUserInfo ya maneja los errores de red y devuelve datos en caché o por defecto\n        if (userData) {\n          setUser(userData);\n          localStorage.setItem('wallet', wallet);\n        } else {\n          console.warn('getUserInfo devolvió datos nulos o indefinidos');\n          setUser(defaultUser);\n        }\n      } catch (err) {\n        console.error('Error inesperado al cargar datos del usuario:', err);\n        setError('Error inesperado al cargar datos del usuario');\n        \n        // Intentar recuperar datos del usuario del localStorage\n        const cachedUserData = localStorage.getItem(`user_${wallet}`);\n        if (cachedUserData) {\n          try {\n            setUser(JSON.parse(cachedUserData));\n          } catch (parseErr) {\n            console.error('Error al parsear datos en caché:', parseErr);\n            setUser(defaultUser);\n          }\n        } else {\n          setUser(defaultUser);\n        }\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Ejecutar fetchUserData solo si hay wallet\n    if (wallet) {\n      fetchUserData();\n    } else {\n      // Si no hay wallet, asegurarse de que user sea null\n      setUser(null);\n      setLoading(false);\n    }\n  }, [wallet]);\n\n  // Función para actualizar la wallet del usuario\n  const updateWallet = (newWallet) => {\n    if (newWallet && newWallet.startsWith('T')) {\n      // Conectar nueva wallet\n      setWallet(newWallet);\n      localStorage.setItem('wallet', newWallet);\n      console.log(`Wallet conectada: ${newWallet}`);\n    } else if (newWallet === null) {\n      // Desconectar wallet\n      console.log('Desconectando wallet...');\n      \n      // Limpiar estado\n      setWallet(null);\n      setUser(null);\n      setError(null);\n      \n      // Limpiar localStorage\n      localStorage.removeItem('wallet');\n      \n      // También podríamos limpiar otros datos relacionados con la wallet\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith('user_') || key.startsWith('p2p_user_'))) {\n          keysToRemove.push(key);\n        }\n      }\n      \n      keysToRemove.forEach(key => {\n        try {\n          localStorage.removeItem(key);\n        } catch (e) {\n          console.error(`Error al eliminar ${key} de localStorage:`, e);\n        }\n      });\n      \n      console.log('Wallet desconectada correctamente');\n    }\n  };\n\n  // Función para actualizar los tokens del usuario después de una consulta\n  const updateTokens = (newTokens) => {\n    if (user) {\n      setUser({\n        ...user,\n        tokens_disponibles: newTokens\n      });\n    }\n  };\n\n  // Función para actualizar el plan del usuario después de un pago\n  const updatePlan = (newPlan, newTokens) => {\n    if (user) {\n      setUser({\n        ...user,\n        plan: newPlan,\n        tokens_disponibles: newTokens\n      });\n    }\n  };\n\n  const value = {\n    user,\n    wallet,\n    loading,\n    error,\n    updateWallet,\n    updateTokens,\n    updatePlan\n  };\n\n  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}