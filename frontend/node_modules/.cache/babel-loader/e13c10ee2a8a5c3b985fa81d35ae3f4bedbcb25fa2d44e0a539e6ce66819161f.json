{"ast":null,"code":"import axios from 'axios';\n\n// Configuración de la URL de la API\n// Aseguramos que la URL sea correcta para el entorno\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5173/api';\n\n// Cliente axios para P2P\nconst p2pClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Interceptor\np2pClient.interceptors.response.use(response => response, error => {\n  // Manejar errores de red\n  if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n    console.warn('Error de conexión a la API P2P. Verificando si hay datos en caché...');\n\n    // La lógica específica para manejar errores de red está en cada función\n  }\n  return Promise.reject(error);\n});\n\n// Datos de ejemplo para usar en modo offline\nconst mockData = {\n  countries: [{\n    code: 'CO',\n    name: 'Colombia',\n    currency: 'COP',\n    price: 3850\n  }, {\n    code: 'MX',\n    name: 'México',\n    currency: 'MXN',\n    price: 17.5\n  }, {\n    code: 'AR',\n    name: 'Argentina',\n    currency: 'ARS',\n    price: 850\n  }, {\n    code: 'VE',\n    name: 'Venezuela',\n    currency: 'VES',\n    price: 36.5\n  }, {\n    code: 'PE',\n    name: 'Perú',\n    currency: 'PEN',\n    price: 3.7\n  }, {\n    code: 'CL',\n    name: 'Chile',\n    currency: 'CLP',\n    price: 950\n  }, {\n    code: 'BR',\n    name: 'Brasil',\n    currency: 'BRL',\n    price: 5.2\n  }, {\n    code: 'ES',\n    name: 'España',\n    currency: 'EUR',\n    price: 0.92\n  }, {\n    code: 'US',\n    name: 'Estados Unidos',\n    currency: 'USD',\n    price: 1\n  }],\n  banks: {\n    CO: [{\n      nombre: 'Bancolombia',\n      swift: 'BANCOL'\n    }, {\n      nombre: 'Banco de Bogotá',\n      swift: 'BBOGCO'\n    }, {\n      nombre: 'Davivienda',\n      swift: 'DAVICO'\n    }, {\n      nombre: 'Nequi',\n      swift: 'NEQUICO'\n    }],\n    MX: [{\n      nombre: 'BBVA México',\n      swift: 'BBVAMX'\n    }, {\n      nombre: 'Banorte',\n      swift: 'BANOMX'\n    }, {\n      nombre: 'Santander México',\n      swift: 'SANTMX'\n    }],\n    AR: [{\n      nombre: 'Banco Nación',\n      swift: 'NACNAR'\n    }, {\n      nombre: 'Banco Galicia',\n      swift: 'GALIAR'\n    }, {\n      nombre: 'Mercado Pago',\n      swift: 'MERCPAR'\n    }]\n  },\n  referencePrices: {\n    CO: {\n      currency: 'COP',\n      price: 3850\n    },\n    MX: {\n      currency: 'MXN',\n      price: 17.5\n    },\n    AR: {\n      currency: 'ARS',\n      price: 850\n    },\n    VE: {\n      currency: 'VES',\n      price: 36.5\n    },\n    PE: {\n      currency: 'PEN',\n      price: 3.7\n    },\n    CL: {\n      currency: 'CLP',\n      price: 950\n    },\n    BR: {\n      currency: 'BRL',\n      price: 5.2\n    },\n    ES: {\n      currency: 'EUR',\n      price: 0.92\n    },\n    US: {\n      currency: 'USD',\n      price: 1\n    }\n  }\n};\n\n// Guardar en localStorage\nconst saveToLocalStorage = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.error('Error guardando en localStorage:', error);\n  }\n};\n\n// Obtener de localStorage\nconst getFromLocalStorage = (key, defaultValue = null) => {\n  try {\n    const data = localStorage.getItem(key);\n    return data ? JSON.parse(data) : defaultValue;\n  } catch (error) {\n    console.error('Error leyendo de localStorage:', error);\n    return defaultValue;\n  }\n};\n\n// Obtener ofertas P2P por país\nexport const getP2POffers = async (country, filters = {}) => {\n  if (!country) {\n    console.error('Error: Se requiere un país para obtener ofertas');\n    return {\n      success: false,\n      error: 'País no especificado',\n      data: [],\n      meta: {\n        total: 0\n      }\n    };\n  }\n  const cacheKey = `p2p_offers_${country}`;\n  try {\n    const response = await p2pClient.get(`/p2p/offers/country/${country}`, {\n      params: filters\n    });\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2POffers no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: [],\n        meta: {\n          total: 0,\n          country: country\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener ofertas P2P:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: [],\n        meta: {\n          total: 0,\n          country: country\n        },\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido',\n      data: [],\n      meta: {\n        total: 0\n      }\n    };\n  }\n};\n\n// Crear nueva oferta P2P\nexport const createP2POffer = async offerData => {\n  if (!offerData || !offerData.wallet) {\n    console.error('Error: Se requieren datos de oferta válidos');\n    return {\n      success: false,\n      error: 'Datos de oferta inválidos'\n    };\n  }\n  const cacheKey = `p2p_user_offers_${offerData.wallet}`;\n  try {\n    const response = await p2pClient.post('/p2p/offers', offerData);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      const userOffers = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      if (response.data.data) {\n        userOffers.data.unshift(response.data.data);\n        saveToLocalStorage(cacheKey, userOffers);\n      }\n      return response.data;\n    } else {\n      console.warn('La respuesta de createP2POffer no tiene la estructura esperada:', response.data);\n      return {\n        success: false,\n        error: 'Respuesta del servidor inválida'\n      };\n    }\n  } catch (error) {\n    var _error$response, _error$response$data;\n    console.error('Error al crear oferta P2P:', error);\n\n    // Si es un error de red, simular respuesta exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, guardando oferta en modo offline');\n\n      // Crear ID temporal\n      const tempId = 'temp_' + Date.now();\n      const newOffer = {\n        ...offerData,\n        id: tempId,\n        status: 'activa',\n        created_at: new Date().toISOString(),\n        trades_completados: 0,\n        _offline: true\n      };\n\n      // Guardar en local\n      const userOffers = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      userOffers.data.unshift(newOffer);\n      saveToLocalStorage(cacheKey, userOffers);\n      return {\n        success: true,\n        data: newOffer,\n        _offline: true,\n        message: 'Oferta creada en modo offline. Se sincronizará cuando el servidor esté disponible.'\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Obtener países disponibles para P2P\nexport const getP2PCountries = async () => {\n  const cacheKey = 'p2p_countries';\n  try {\n    const response = await p2pClient.get('/p2p/countries');\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2PCountries no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para países P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      return {\n        success: true,\n        data: mockData.countries\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener países P2P:', error);\n\n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para países P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      return {\n        success: true,\n        data: mockData.countries,\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido',\n      data: []\n    };\n  }\n};\n\n// Obtener bancos por país\nexport const getBanksByCountry = async countryCode => {\n  if (!countryCode) {\n    console.error('Error: Se requiere un código de país para obtener bancos');\n    return {\n      success: false,\n      data: {\n        banks: []\n      }\n    };\n  }\n  const cacheKey = `p2p_banks_${countryCode}`;\n  try {\n    const response = await p2pClient.get(`/p2p/banks/${countryCode}`);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      var _mockData$countries$f, _mockData$countries$f2;\n      console.warn('La respuesta de getBanksByCountry no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para bancos');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      const countryBanks = mockData.banks[countryCode] || [];\n      return {\n        success: true,\n        data: {\n          country: {\n            code: countryCode,\n            name: ((_mockData$countries$f = mockData.countries.find(c => c.code === countryCode)) === null || _mockData$countries$f === void 0 ? void 0 : _mockData$countries$f.name) || countryCode,\n            currency: ((_mockData$countries$f2 = mockData.countries.find(c => c.code === countryCode)) === null || _mockData$countries$f2 === void 0 ? void 0 : _mockData$countries$f2.currency) || 'USD'\n          },\n          banks: countryBanks\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener bancos por país:', error);\n\n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      var _mockData$countries$f3, _mockData$countries$f4;\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para bancos');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      const countryBanks = mockData.banks[countryCode] || [];\n      return {\n        success: true,\n        data: {\n          country: {\n            code: countryCode,\n            name: ((_mockData$countries$f3 = mockData.countries.find(c => c.code === countryCode)) === null || _mockData$countries$f3 === void 0 ? void 0 : _mockData$countries$f3.name) || countryCode,\n            currency: ((_mockData$countries$f4 = mockData.countries.find(c => c.code === countryCode)) === null || _mockData$countries$f4 === void 0 ? void 0 : _mockData$countries$f4.currency) || 'USD'\n          },\n          banks: countryBanks\n        },\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido',\n      data: {\n        banks: []\n      }\n    };\n  }\n};\n\n// Obtener ofertas del usuario\nexport const getUserP2POffers = async wallet => {\n  if (!wallet) {\n    console.error('Error: Se requiere una wallet para obtener ofertas del usuario');\n    return {\n      success: false,\n      data: [],\n      meta: {\n        total: 0\n      }\n    };\n  }\n  const cacheKey = `p2p_user_offers_${wallet}`;\n  try {\n    const response = await p2pClient.get(`/p2p/offers/wallet/${wallet}`);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getUserP2POffers no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas del usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: [],\n        meta: {\n          total: 0\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener ofertas del usuario:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas del usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: [],\n        meta: {\n          total: 0\n        },\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido',\n      data: [],\n      meta: {\n        total: 0\n      }\n    };\n  }\n};\n\n// Actualizar estado de oferta\nexport const updateOfferStatus = async (offerId, wallet, status) => {\n  if (!offerId || !wallet || !status) {\n    console.error('Error: Se requieren datos válidos para actualizar estado');\n    return {\n      success: false,\n      error: 'Datos inválidos'\n    };\n  }\n  const cacheKey = `p2p_user_offers_${wallet}`;\n  try {\n    const response = await p2pClient.put(`/p2p/offers/${offerId}/status`, {\n      wallet,\n      status\n    });\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Actualizar caché\n      const userOffers = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      const updatedOffers = userOffers.data.map(offer => offer.id === offerId ? {\n        ...offer,\n        status\n      } : offer);\n      userOffers.data = updatedOffers;\n      saveToLocalStorage(cacheKey, userOffers);\n      return response.data;\n    } else {\n      console.warn('La respuesta de updateOfferStatus no tiene la estructura esperada:', response.data);\n      return {\n        success: false,\n        error: 'Respuesta del servidor inválida'\n      };\n    }\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    console.error('Error al actualizar estado de oferta:', error);\n\n    // Si es un error de red, actualizar localmente\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, actualizando oferta localmente');\n\n      // Actualizar en caché local\n      const userOffers = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      const updatedOffers = userOffers.data.map(offer => offer.id === offerId ? {\n        ...offer,\n        status,\n        _offline: true\n      } : offer);\n      userOffers.data = updatedOffers;\n      saveToLocalStorage(cacheKey, userOffers);\n      const updatedOffer = updatedOffers.find(offer => offer.id === offerId);\n      if (updatedOffer) {\n        return {\n          success: true,\n          data: updatedOffer,\n          _offline: true,\n          message: 'Estado actualizado en modo offline. Se sincronizará cuando el servidor esté disponible.'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se encontró la oferta para actualizar',\n          _offline: true\n        };\n      }\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Crear orden P2P\nexport const createP2POrder = async orderData => {\n  if (!orderData || !orderData.wallet) {\n    console.error('Error: Se requieren datos de orden válidos');\n    return {\n      success: false,\n      error: 'Datos de orden inválidos'\n    };\n  }\n  const cacheKey = `p2p_user_orders_${orderData.wallet}`;\n  try {\n    const response = await p2pClient.post('/p2p/orders', orderData);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      const userOrders = getFromLocalStorage(cacheKey, {\n        success: true,\n        orders: []\n      });\n      if (response.data.order) {\n        userOrders.orders.unshift(response.data.order);\n        saveToLocalStorage(cacheKey, userOrders);\n      }\n      return response.data;\n    } else {\n      console.warn('La respuesta de createP2POrder no tiene la estructura esperada:', response.data);\n      return {\n        success: false,\n        error: 'Respuesta del servidor inválida'\n      };\n    }\n  } catch (error) {\n    var _error$response3, _error$response3$data;\n    console.error('Error al crear orden P2P:', error);\n\n    // Si es un error de red, simular respuesta exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, guardando orden en local');\n\n      // Crear ID temporal y orden\n      const tempId = 'temp_' + Date.now();\n      const newOrder = {\n        ...orderData,\n        order_id: tempId,\n        status: 'active',\n        created_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        _offline: true\n      };\n\n      // Guardar en caché local\n      const userOrders = getFromLocalStorage(cacheKey, {\n        success: true,\n        orders: []\n      });\n      userOrders.orders.unshift(newOrder);\n      saveToLocalStorage(cacheKey, userOrders);\n      return {\n        success: true,\n        order: newOrder,\n        _offline: true,\n        message: 'Orden creada en modo offline. Se sincronizará cuando el servidor esté disponible.'\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Obtener órdenes P2P del usuario\nexport const getUserP2POrders = async wallet => {\n  if (!wallet) {\n    console.error('Error: Se requiere una wallet para obtener órdenes del usuario');\n    return {\n      success: false,\n      orders: []\n    };\n  }\n  const cacheKey = `p2p_user_orders_${wallet}`;\n  try {\n    const response = await p2pClient.get(`/p2p/orders/wallet/${wallet}`);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getUserP2POrders no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para órdenes del usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        orders: []\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener órdenes P2P del usuario:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para órdenes del usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        orders: [],\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido',\n      orders: []\n    };\n  }\n};\n\n// Obtener estadísticas P2P\nexport const getP2PStats = async () => {\n  const cacheKey = 'p2p_stats';\n  try {\n    const response = await p2pClient.get('/p2p/stats');\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2PStats no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para estadísticas P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: {\n          total_offers: 0,\n          active_offers: 0,\n          total_orders: 0,\n          completed_orders: 0,\n          countries: {},\n          payment_methods: {},\n          by_type: {\n            compra: 0,\n            venta: 0\n          }\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener estadísticas P2P:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para estadísticas P2P');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, devolver un objeto vacío\n      return {\n        success: true,\n        data: {\n          total_offers: 0,\n          active_offers: 0,\n          total_orders: 0,\n          completed_orders: 0,\n          countries: {},\n          payment_methods: {},\n          by_type: {\n            compra: 0,\n            venta: 0\n          }\n        },\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Obtener precios de referencia\nexport const getReferencePrices = async () => {\n  const cacheKey = 'p2p_reference_prices';\n  try {\n    const response = await p2pClient.get('/p2p/reference-prices');\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getReferencePrices no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para precios de referencia');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      return {\n        success: true,\n        data: mockData.referencePrices\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener precios de referencia:', error);\n\n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para precios de referencia');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar datos de ejemplo\n      return {\n        success: true,\n        data: mockData.referencePrices,\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Actualizar estado de una orden P2P\nexport const updateP2POrderStatus = async (orderId, status, data = {}) => {\n  if (!orderId || !status) {\n    console.error('Error: Se requieren datos válidos para actualizar estado de orden');\n    return {\n      success: false,\n      error: 'Datos inválidos'\n    };\n  }\n  const cacheKey = `p2p_user_orders_${data.wallet}`;\n  try {\n    const response = await p2pClient.put(`/p2p/orders/${orderId}/status`, {\n      status,\n      ...data\n    });\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Actualizar caché\n      const userOrders = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      const updatedOrders = userOrders.data.map(order => order.id === orderId ? {\n        ...order,\n        estado: status,\n        ...data\n      } : order);\n      userOrders.data = updatedOrders;\n      saveToLocalStorage(cacheKey, userOrders);\n      return response.data;\n    } else {\n      console.warn('La respuesta de updateP2POrderStatus no tiene la estructura esperada:', response.data);\n      return {\n        success: false,\n        error: 'Respuesta del servidor inválida'\n      };\n    }\n  } catch (error) {\n    var _error$response4, _error$response4$data;\n    console.error('Error al actualizar estado de orden P2P:', error);\n\n    // Si es un error de red, actualizar localmente\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, actualizando orden localmente');\n\n      // Actualizar en caché local\n      const userOrders = getFromLocalStorage(cacheKey, {\n        success: true,\n        data: []\n      });\n      const updatedOrders = userOrders.data.map(order => order.id === orderId ? {\n        ...order,\n        estado: status,\n        ...data,\n        _offline: true\n      } : order);\n      userOrders.data = updatedOrders;\n      saveToLocalStorage(cacheKey, userOrders);\n      const updatedOrder = updatedOrders.find(order => order.id === orderId);\n      if (updatedOrder) {\n        return {\n          success: true,\n          data: updatedOrder,\n          _offline: true,\n          message: 'Estado de orden actualizado en modo offline. Se sincronizará cuando el servidor esté disponible.'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se encontró la orden para actualizar',\n          _offline: true\n        };\n      }\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || error.message || 'Error desconocido'\n    };\n  }\n};\n\n// Obtener detalles de una oferta específica\nexport const getOfferDetails = async offerId => {\n  if (!offerId) {\n    console.error('Error: Se requiere un ID de oferta');\n    return {\n      success: false,\n      error: 'ID de oferta no especificado'\n    };\n  }\n  const cacheKey = `p2p_offer_${offerId}`;\n  try {\n    const response = await p2pClient.get(`/p2p/offers/${offerId}`);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getOfferDetails no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para detalles de oferta');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, buscar en todas las ofertas\n      const allOffers = getFromLocalStorage('p2p_offers_all');\n      if (allOffers && allOffers.data) {\n        const foundOffer = allOffers.data.find(offer => offer.id === offerId);\n        if (foundOffer) {\n          return {\n            success: true,\n            data: foundOffer\n          };\n        }\n      }\n      return {\n        success: false,\n        error: 'Oferta no encontrada'\n      };\n    }\n  } catch (error) {\n    var _error$response5, _error$response5$data;\n    console.error('Error al obtener detalles de oferta:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para detalles de oferta');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché específica, buscar en todas las ofertas\n      const allOffers = getFromLocalStorage('p2p_offers_all');\n      if (allOffers && allOffers.data) {\n        const foundOffer = allOffers.data.find(offer => offer.id === offerId);\n        if (foundOffer) {\n          return {\n            success: true,\n            data: foundOffer,\n            _offline: true\n          };\n        }\n      }\n      return {\n        success: false,\n        error: 'Oferta no encontrada en modo offline',\n        _offline: true\n      };\n    }\n\n    // Para otros errores, devolver un objeto de error\n    return {\n      success: false,\n      error: ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.error) || error.message || 'Error desconocido'\n    };\n  }\n};\nexport default {\n  getP2POffers,\n  createP2POffer,\n  getP2PCountries,\n  getBanksByCountry,\n  getUserP2POffers,\n  updateOfferStatus,\n  createP2POrder,\n  getUserP2POrders,\n  getP2PStats,\n  getReferencePrices,\n  updateP2POrderStatus,\n  getOfferDetails\n};","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","p2pClient","create","baseURL","headers","interceptors","response","use","error","message","code","console","warn","Promise","reject","mockData","countries","name","currency","price","banks","CO","nombre","swift","MX","AR","referencePrices","VE","PE","CL","BR","ES","US","saveToLocalStorage","key","data","localStorage","setItem","JSON","stringify","getFromLocalStorage","defaultValue","getItem","parse","getP2POffers","country","filters","success","meta","total","cacheKey","get","params","undefined","cachedData","log","_offline","createP2POffer","offerData","wallet","post","userOffers","unshift","_error$response","_error$response$data","tempId","Date","now","newOffer","id","status","created_at","toISOString","trades_completados","getP2PCountries","getBanksByCountry","countryCode","_mockData$countries$f","_mockData$countries$f2","countryBanks","find","c","_mockData$countries$f3","_mockData$countries$f4","getUserP2POffers","updateOfferStatus","offerId","put","updatedOffers","map","offer","_error$response2","_error$response2$data","updatedOffer","createP2POrder","orderData","userOrders","orders","order","_error$response3","_error$response3$data","newOrder","order_id","expires_at","getUserP2POrders","getP2PStats","total_offers","active_offers","total_orders","completed_orders","payment_methods","by_type","compra","venta","getReferencePrices","updateP2POrderStatus","orderId","updatedOrders","estado","_error$response4","_error$response4$data","updatedOrder","getOfferDetails","allOffers","foundOffer","_error$response5","_error$response5$data"],"sources":["/Volumes/DATOS/verificador/verificadortrx/frontend/src/services/p2pService.js"],"sourcesContent":["import axios from 'axios';\n\n// Configuración de la URL de la API\n// Aseguramos que la URL sea correcta para el entorno\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5173/api';\n\n// Cliente axios para P2P\nconst p2pClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Interceptor\np2pClient.interceptors.response.use(\n  response => response,\n  error => {\n    // Manejar errores de red\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.warn('Error de conexión a la API P2P. Verificando si hay datos en caché...');\n      \n      // La lógica específica para manejar errores de red está en cada función\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// Datos de ejemplo para usar en modo offline\nconst mockData = {\n  countries: [\n    { code: 'CO', name: 'Colombia', currency: 'COP', price: 3850 },\n    { code: 'MX', name: 'México', currency: 'MXN', price: 17.5 },\n    { code: 'AR', name: 'Argentina', currency: 'ARS', price: 850 },\n    { code: 'VE', name: 'Venezuela', currency: 'VES', price: 36.5 },\n    { code: 'PE', name: 'Perú', currency: 'PEN', price: 3.7 },\n    { code: 'CL', name: 'Chile', currency: 'CLP', price: 950 },\n    { code: 'BR', name: 'Brasil', currency: 'BRL', price: 5.2 },\n    { code: 'ES', name: 'España', currency: 'EUR', price: 0.92 },\n    { code: 'US', name: 'Estados Unidos', currency: 'USD', price: 1 }\n  ],\n  banks: {\n    CO: [\n      { nombre: 'Bancolombia', swift: 'BANCOL' },\n      { nombre: 'Banco de Bogotá', swift: 'BBOGCO' },\n      { nombre: 'Davivienda', swift: 'DAVICO' },\n      { nombre: 'Nequi', swift: 'NEQUICO' }\n    ],\n    MX: [\n      { nombre: 'BBVA México', swift: 'BBVAMX' },\n      { nombre: 'Banorte', swift: 'BANOMX' },\n      { nombre: 'Santander México', swift: 'SANTMX' }\n    ],\n    AR: [\n      { nombre: 'Banco Nación', swift: 'NACNAR' },\n      { nombre: 'Banco Galicia', swift: 'GALIAR' },\n      { nombre: 'Mercado Pago', swift: 'MERCPAR' }\n    ]\n  },\n  referencePrices: {\n    CO: { currency: 'COP', price: 3850 },\n    MX: { currency: 'MXN', price: 17.5 },\n    AR: { currency: 'ARS', price: 850 },\n    VE: { currency: 'VES', price: 36.5 },\n    PE: { currency: 'PEN', price: 3.7 },\n    CL: { currency: 'CLP', price: 950 },\n    BR: { currency: 'BRL', price: 5.2 },\n    ES: { currency: 'EUR', price: 0.92 },\n    US: { currency: 'USD', price: 1 }\n  }\n};\n\n// Guardar en localStorage\nconst saveToLocalStorage = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.error('Error guardando en localStorage:', error);\n  }\n};\n\n// Obtener de localStorage\nconst getFromLocalStorage = (key, defaultValue = null) => {\n  try {\n    const data = localStorage.getItem(key);\n    return data ? JSON.parse(data) : defaultValue;\n  } catch (error) {\n    console.error('Error leyendo de localStorage:', error);\n    return defaultValue;\n  }\n};\n\n// Obtener ofertas P2P por país\nexport const getP2POffers = async (country, filters = {}) => {\n  if (!country) {\n    console.error('Error: Se requiere un país para obtener ofertas');\n    return { success: false, error: 'País no especificado', data: [], meta: { total: 0 } };\n  }\n  \n  const cacheKey = `p2p_offers_${country}`;\n  \n  try {\n    const response = await p2pClient.get(`/p2p/offers/country/${country}`, {\n      params: filters\n    });\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2POffers no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: [],\n        meta: { \n          total: 0, \n          country: country \n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener ofertas P2P:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: [],\n        meta: { \n          total: 0,\n          country: country\n        },\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido',\n      data: [],\n      meta: { total: 0 }\n    };\n  }\n};\n\n// Crear nueva oferta P2P\nexport const createP2POffer = async (offerData) => {\n  if (!offerData || !offerData.wallet) {\n    console.error('Error: Se requieren datos de oferta válidos');\n    return { success: false, error: 'Datos de oferta inválidos' };\n  }\n  \n  const cacheKey = `p2p_user_offers_${offerData.wallet}`;\n  \n  try {\n    const response = await p2pClient.post('/p2p/offers', offerData);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      const userOffers = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      \n      if (response.data.data) {\n        userOffers.data.unshift(response.data.data);\n        saveToLocalStorage(cacheKey, userOffers);\n      }\n      \n      return response.data;\n    } else {\n      console.warn('La respuesta de createP2POffer no tiene la estructura esperada:', response.data);\n      return { success: false, error: 'Respuesta del servidor inválida' };\n    }\n  } catch (error) {\n    console.error('Error al crear oferta P2P:', error);\n    \n    // Si es un error de red, simular respuesta exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, guardando oferta en modo offline');\n      \n      // Crear ID temporal\n      const tempId = 'temp_' + Date.now();\n      const newOffer = {\n        ...offerData,\n        id: tempId,\n        status: 'activa',\n        created_at: new Date().toISOString(),\n        trades_completados: 0,\n        _offline: true\n      };\n      \n      // Guardar en local\n      const userOffers = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      userOffers.data.unshift(newOffer);\n      saveToLocalStorage(cacheKey, userOffers);\n      \n      return {\n        success: true,\n        data: newOffer,\n        _offline: true,\n        message: 'Oferta creada en modo offline. Se sincronizará cuando el servidor esté disponible.'\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.response?.data?.error || error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Obtener países disponibles para P2P\nexport const getP2PCountries = async () => {\n  const cacheKey = 'p2p_countries';\n  \n  try {\n    const response = await p2pClient.get('/p2p/countries');\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2PCountries no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para países P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      return { \n        success: true, \n        data: mockData.countries\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener países P2P:', error);\n    \n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para países P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      return { \n        success: true, \n        data: mockData.countries,\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido',\n      data: []\n    };\n  }\n};\n\n// Obtener bancos por país\nexport const getBanksByCountry = async (countryCode) => {\n  if (!countryCode) {\n    console.error('Error: Se requiere un código de país para obtener bancos');\n    return { success: false, data: { banks: [] } };\n  }\n  \n  const cacheKey = `p2p_banks_${countryCode}`;\n  \n  try {\n    const response = await p2pClient.get(`/p2p/banks/${countryCode}`);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getBanksByCountry no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para bancos');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      const countryBanks = mockData.banks[countryCode] || [];\n      \n      return { \n        success: true, \n        data: {\n          country: {\n            code: countryCode,\n            name: mockData.countries.find(c => c.code === countryCode)?.name || countryCode,\n            currency: mockData.countries.find(c => c.code === countryCode)?.currency || 'USD'\n          },\n          banks: countryBanks\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener bancos por país:', error);\n    \n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para bancos');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      const countryBanks = mockData.banks[countryCode] || [];\n      \n      return { \n        success: true, \n        data: {\n          country: {\n            code: countryCode,\n            name: mockData.countries.find(c => c.code === countryCode)?.name || countryCode,\n            currency: mockData.countries.find(c => c.code === countryCode)?.currency || 'USD'\n          },\n          banks: countryBanks\n        },\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido',\n      data: { banks: [] }\n    };\n  }\n};\n\n// Obtener ofertas del usuario\nexport const getUserP2POffers = async (wallet) => {\n  if (!wallet) {\n    console.error('Error: Se requiere una wallet para obtener ofertas del usuario');\n    return { success: false, data: [], meta: { total: 0 } };\n  }\n  \n  const cacheKey = `p2p_user_offers_${wallet}`;\n  \n  try {\n    const response = await p2pClient.get(`/p2p/offers/wallet/${wallet}`);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getUserP2POffers no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas del usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: [],\n        meta: { total: 0 }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener ofertas del usuario:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para ofertas del usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: [],\n        meta: { total: 0 },\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido',\n      data: [],\n      meta: { total: 0 }\n    };\n  }\n};\n\n// Actualizar estado de oferta\nexport const updateOfferStatus = async (offerId, wallet, status) => {\n  if (!offerId || !wallet || !status) {\n    console.error('Error: Se requieren datos válidos para actualizar estado');\n    return { success: false, error: 'Datos inválidos' };\n  }\n  \n  const cacheKey = `p2p_user_offers_${wallet}`;\n  \n  try {\n    const response = await p2pClient.put(`/p2p/offers/${offerId}/status`, {\n      wallet,\n      status\n    });\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Actualizar caché\n      const userOffers = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      const updatedOffers = userOffers.data.map(offer => \n        offer.id === offerId ? { ...offer, status } : offer\n      );\n      userOffers.data = updatedOffers;\n      saveToLocalStorage(cacheKey, userOffers);\n      \n      return response.data;\n    } else {\n      console.warn('La respuesta de updateOfferStatus no tiene la estructura esperada:', response.data);\n      return { success: false, error: 'Respuesta del servidor inválida' };\n    }\n  } catch (error) {\n    console.error('Error al actualizar estado de oferta:', error);\n    \n    // Si es un error de red, actualizar localmente\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, actualizando oferta localmente');\n      \n      // Actualizar en caché local\n      const userOffers = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      const updatedOffers = userOffers.data.map(offer => \n        offer.id === offerId ? { ...offer, status, _offline: true } : offer\n      );\n      userOffers.data = updatedOffers;\n      saveToLocalStorage(cacheKey, userOffers);\n      \n      const updatedOffer = updatedOffers.find(offer => offer.id === offerId);\n      \n      if (updatedOffer) {\n        return {\n          success: true,\n          data: updatedOffer,\n          _offline: true,\n          message: 'Estado actualizado en modo offline. Se sincronizará cuando el servidor esté disponible.'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se encontró la oferta para actualizar',\n          _offline: true\n        };\n      }\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.response?.data?.error || error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Crear orden P2P\nexport const createP2POrder = async (orderData) => {\n  if (!orderData || !orderData.wallet) {\n    console.error('Error: Se requieren datos de orden válidos');\n    return { success: false, error: 'Datos de orden inválidos' };\n  }\n  \n  const cacheKey = `p2p_user_orders_${orderData.wallet}`;\n  \n  try {\n    const response = await p2pClient.post('/p2p/orders', orderData);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      const userOrders = getFromLocalStorage(cacheKey, { success: true, orders: [] });\n      \n      if (response.data.order) {\n        userOrders.orders.unshift(response.data.order);\n        saveToLocalStorage(cacheKey, userOrders);\n      }\n      \n      return response.data;\n    } else {\n      console.warn('La respuesta de createP2POrder no tiene la estructura esperada:', response.data);\n      return { success: false, error: 'Respuesta del servidor inválida' };\n    }\n  } catch (error) {\n    console.error('Error al crear orden P2P:', error);\n    \n    // Si es un error de red, simular respuesta exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, guardando orden en local');\n      \n      // Crear ID temporal y orden\n      const tempId = 'temp_' + Date.now();\n      const newOrder = {\n        ...orderData,\n        order_id: tempId,\n        status: 'active',\n        created_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n        _offline: true\n      };\n      \n      // Guardar en caché local\n      const userOrders = getFromLocalStorage(cacheKey, { success: true, orders: [] });\n      userOrders.orders.unshift(newOrder);\n      saveToLocalStorage(cacheKey, userOrders);\n      \n      return {\n        success: true,\n        order: newOrder,\n        _offline: true,\n        message: 'Orden creada en modo offline. Se sincronizará cuando el servidor esté disponible.'\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.response?.data?.error || error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Obtener órdenes P2P del usuario\nexport const getUserP2POrders = async (wallet) => {\n  if (!wallet) {\n    console.error('Error: Se requiere una wallet para obtener órdenes del usuario');\n    return { success: false, orders: [] };\n  }\n  \n  const cacheKey = `p2p_user_orders_${wallet}`;\n  \n  try {\n    const response = await p2pClient.get(`/p2p/orders/wallet/${wallet}`);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getUserP2POrders no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para órdenes del usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        orders: []\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener órdenes P2P del usuario:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para órdenes del usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        orders: [],\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido',\n      orders: []\n    };\n  }\n};\n\n// Obtener estadísticas P2P\nexport const getP2PStats = async () => {\n  const cacheKey = 'p2p_stats';\n  \n  try {\n    const response = await p2pClient.get('/p2p/stats');\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getP2PStats no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para estadísticas P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: {\n          total_offers: 0,\n          active_offers: 0,\n          total_orders: 0,\n          completed_orders: 0,\n          countries: {},\n          payment_methods: {},\n          by_type: { compra: 0, venta: 0 }\n        }\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener estadísticas P2P:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para estadísticas P2P');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, devolver un objeto vacío\n      return { \n        success: true, \n        data: {\n          total_offers: 0,\n          active_offers: 0,\n          total_orders: 0,\n          completed_orders: 0,\n          countries: {},\n          payment_methods: {},\n          by_type: { compra: 0, venta: 0 }\n        },\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Obtener precios de referencia\nexport const getReferencePrices = async () => {\n  const cacheKey = 'p2p_reference_prices';\n  \n  try {\n    const response = await p2pClient.get('/p2p/reference-prices');\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getReferencePrices no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para precios de referencia');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      return { \n        success: true, \n        data: mockData.referencePrices\n      };\n    }\n  } catch (error) {\n    console.error('Error al obtener precios de referencia:', error);\n    \n    // Si es un error de red, usar datos en caché o los de ejemplo\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para precios de referencia');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar datos de ejemplo\n      return { \n        success: true, \n        data: mockData.referencePrices,\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Actualizar estado de una orden P2P\nexport const updateP2POrderStatus = async (orderId, status, data = {}) => {\n  if (!orderId || !status) {\n    console.error('Error: Se requieren datos válidos para actualizar estado de orden');\n    return { success: false, error: 'Datos inválidos' };\n  }\n  \n  const cacheKey = `p2p_user_orders_${data.wallet}`;\n  \n  try {\n    const response = await p2pClient.put(`/p2p/orders/${orderId}/status`, {\n      status,\n      ...data\n    });\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Actualizar caché\n      const userOrders = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      const updatedOrders = userOrders.data.map(order => \n        order.id === orderId ? { ...order, estado: status, ...data } : order\n      );\n      userOrders.data = updatedOrders;\n      saveToLocalStorage(cacheKey, userOrders);\n      \n      return response.data;\n    } else {\n      console.warn('La respuesta de updateP2POrderStatus no tiene la estructura esperada:', response.data);\n      return { success: false, error: 'Respuesta del servidor inválida' };\n    }\n  } catch (error) {\n    console.error('Error al actualizar estado de orden P2P:', error);\n    \n    // Si es un error de red, actualizar localmente\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, actualizando orden localmente');\n      \n      // Actualizar en caché local\n      const userOrders = getFromLocalStorage(cacheKey, { success: true, data: [] });\n      const updatedOrders = userOrders.data.map(order => \n        order.id === orderId ? { ...order, estado: status, ...data, _offline: true } : order\n      );\n      userOrders.data = updatedOrders;\n      saveToLocalStorage(cacheKey, userOrders);\n      \n      const updatedOrder = updatedOrders.find(order => order.id === orderId);\n      \n      if (updatedOrder) {\n        return {\n          success: true,\n          data: updatedOrder,\n          _offline: true,\n          message: 'Estado de orden actualizado en modo offline. Se sincronizará cuando el servidor esté disponible.'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se encontró la orden para actualizar',\n          _offline: true\n        };\n      }\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.response?.data?.error || error.message || 'Error desconocido' \n    };\n  }\n};\n\n// Obtener detalles de una oferta específica\nexport const getOfferDetails = async (offerId) => {\n  if (!offerId) {\n    console.error('Error: Se requiere un ID de oferta');\n    return { success: false, error: 'ID de oferta no especificado' };\n  }\n  \n  const cacheKey = `p2p_offer_${offerId}`;\n  \n  try {\n    const response = await p2pClient.get(`/p2p/offers/${offerId}`);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.success !== undefined) {\n      // Guardar en caché\n      saveToLocalStorage(cacheKey, response.data);\n      return response.data;\n    } else {\n      console.warn('La respuesta de getOfferDetails no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para detalles de oferta');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, buscar en todas las ofertas\n      const allOffers = getFromLocalStorage('p2p_offers_all');\n      if (allOffers && allOffers.data) {\n        const foundOffer = allOffers.data.find(offer => offer.id === offerId);\n        if (foundOffer) {\n          return { success: true, data: foundOffer };\n        }\n      }\n      \n      return { success: false, error: 'Oferta no encontrada' };\n    }\n  } catch (error) {\n    console.error('Error al obtener detalles de oferta:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para detalles de oferta');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché específica, buscar en todas las ofertas\n      const allOffers = getFromLocalStorage('p2p_offers_all');\n      if (allOffers && allOffers.data) {\n        const foundOffer = allOffers.data.find(offer => offer.id === offerId);\n        if (foundOffer) {\n          return { success: true, data: foundOffer, _offline: true };\n        }\n      }\n      \n      return { \n        success: false, \n        error: 'Oferta no encontrada en modo offline',\n        _offline: true\n      };\n    }\n    \n    // Para otros errores, devolver un objeto de error\n    return { \n      success: false, \n      error: error.response?.data?.error || error.message || 'Error desconocido' \n    };\n  }\n};\n\nexport default {\n  getP2POffers,\n  createP2POffer,\n  getP2PCountries,\n  getBanksByCountry,\n  getUserP2POffers,\n  updateOfferStatus,\n  createP2POrder,\n  getUserP2POrders,\n  getP2PStats,\n  getReferencePrices,\n  updateP2POrderStatus,\n  getOfferDetails\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}