{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nconst useIPLimits = () => {\n  _s();\n  const [ipLimits, setIpLimits] = useState({\n    remaining: 3,\n    resetTime: null,\n    canScan: true\n  });\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    checkIPLimits();\n  }, []);\n  const checkIPLimits = async () => {\n    try {\n      setLoading(true);\n      const response = await fetch(`${process.env.REACT_APP_API_URL}/ip-limits/check`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const data = await response.json();\n      if (response.ok) {\n        setIpLimits({\n          remaining: data.remaining,\n          resetTime: data.resetTime,\n          canScan: data.remaining > 0\n        });\n      }\n    } catch (error) {\n      console.error('Error checking IP limits:', error);\n      // Default to allowing scans if there's an error\n      setIpLimits({\n        remaining: 3,\n        resetTime: null,\n        canScan: true\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n  const consumeIPLimit = async () => {\n    try {\n      const response = await fetch(`${process.env.REACT_APP_API_URL}/ip-limits/consume`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const data = await response.json();\n      if (response.ok) {\n        setIpLimits({\n          remaining: data.remaining,\n          resetTime: data.resetTime,\n          canScan: data.remaining > 0\n        });\n        return {\n          success: true,\n          data\n        };\n      } else {\n        return {\n          success: false,\n          message: data.message\n        };\n      }\n    } catch (error) {\n      console.error('Error consuming IP limit:', error);\n      return {\n        success: false,\n        message: 'Network error'\n      };\n    }\n  };\n  const getTimeUntilReset = () => {\n    if (!ipLimits.resetTime) return null;\n    const now = new Date().getTime();\n    const resetTime = new Date(ipLimits.resetTime).getTime();\n    const diff = resetTime - now;\n    if (diff <= 0) return null;\n    const hours = Math.floor(diff / (1000 * 60 * 60));\n    const minutes = Math.floor(diff % (1000 * 60 * 60) / (1000 * 60));\n    return {\n      hours,\n      minutes\n    };\n  };\n  return {\n    ipLimits,\n    loading,\n    checkIPLimits,\n    consumeIPLimit,\n    getTimeUntilReset\n  };\n};\n_s(useIPLimits, \"lEz03vBYYmdChYi60rv/Rw7tZ0g=\");\nexport default useIPLimits;","map":{"version":3,"names":["useState","useEffect","useIPLimits","_s","ipLimits","setIpLimits","remaining","resetTime","canScan","loading","setLoading","checkIPLimits","response","fetch","process","env","REACT_APP_API_URL","method","headers","data","json","ok","error","console","consumeIPLimit","success","message","getTimeUntilReset","now","Date","getTime","diff","hours","Math","floor","minutes"],"sources":["/Volumes/DATOS/verificador/verificadortrx/frontend/src/hooks/useIPLimits.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useIPLimits = () => {\n  const [ipLimits, setIpLimits] = useState({\n    remaining: 3,\n    resetTime: null,\n    canScan: true\n  });\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    checkIPLimits();\n  }, []);\n\n  const checkIPLimits = async () => {\n    try {\n      setLoading(true);\n      const response = await fetch(`${process.env.REACT_APP_API_URL}/ip-limits/check`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const data = await response.json();\n      \n      if (response.ok) {\n        setIpLimits({\n          remaining: data.remaining,\n          resetTime: data.resetTime,\n          canScan: data.remaining > 0\n        });\n      }\n    } catch (error) {\n      console.error('Error checking IP limits:', error);\n      // Default to allowing scans if there's an error\n      setIpLimits({\n        remaining: 3,\n        resetTime: null,\n        canScan: true\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const consumeIPLimit = async () => {\n    try {\n      const response = await fetch(`${process.env.REACT_APP_API_URL}/ip-limits/consume`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const data = await response.json();\n      \n      if (response.ok) {\n        setIpLimits({\n          remaining: data.remaining,\n          resetTime: data.resetTime,\n          canScan: data.remaining > 0\n        });\n        return { success: true, data };\n      } else {\n        return { success: false, message: data.message };\n      }\n    } catch (error) {\n      console.error('Error consuming IP limit:', error);\n      return { success: false, message: 'Network error' };\n    }\n  };\n\n  const getTimeUntilReset = () => {\n    if (!ipLimits.resetTime) return null;\n    \n    const now = new Date().getTime();\n    const resetTime = new Date(ipLimits.resetTime).getTime();\n    const diff = resetTime - now;\n    \n    if (diff <= 0) return null;\n    \n    const hours = Math.floor(diff / (1000 * 60 * 60));\n    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n    \n    return { hours, minutes };\n  };\n\n  return {\n    ipLimits,\n    loading,\n    checkIPLimits,\n    consumeIPLimit,\n    getTimeUntilReset\n  };\n};\n\nexport default useIPLimits;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}