{"ast":null,"code":"import axios from 'axios';\n\n// Configuración de la URL de la API\n// Usar la variable de entorno REACT_APP_API_URL si está definida, de lo contrario usar la URL por defecto\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5173/api';\n\n// Cliente axios con configuración base\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  timeout: 30000 // 30 segundos de timeout para consultas blockchain\n});\n\n// Interceptor para manejar errores de red\napiClient.interceptors.response.use(response => response, error => {\n  // Manejar errores de red\n  if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n    console.warn('Error de conexión a la API. Verificando si hay datos en caché...');\n\n    // Aquí podríamos implementar una lógica más avanzada para manejar errores de red\n    // Por ahora, simplemente propagamos el error\n  }\n  return Promise.reject(error);\n});\n\n// Función para guardar datos en localStorage\nconst saveToLocalStorage = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.error('Error guardando en localStorage:', error);\n  }\n};\n\n// Función para obtener datos de localStorage\nconst getFromLocalStorage = (key, defaultValue = null) => {\n  try {\n    const data = localStorage.getItem(key);\n    return data ? JSON.parse(data) : defaultValue;\n  } catch (error) {\n    console.error('Error leyendo de localStorage:', error);\n    return defaultValue;\n  }\n};\n\n// Verificación básica de wallet (sin consumir token)\nexport const verifyWalletBasic = async wallet => {\n  try {\n    const response = await apiClient.get(`/verify/basic/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error en verificación básica:', error);\n    throw error;\n  }\n};\n\n// Verificación completa de wallet (consume 1 token)\nexport const verifyWallet = async wallet => {\n  try {\n    console.log(`Iniciando verificación de wallet: ${wallet}`);\n\n    // Primero verificar el estado de la conexión con TRON\n    try {\n      const statusResponse = await apiClient.get('/verify/status');\n      console.log('Estado de conexión TRON:', statusResponse.data);\n      if (!statusResponse.data.success) {\n        console.warn('La conexión con TRON no está disponible, intentando con método alternativo');\n      }\n    } catch (statusError) {\n      console.warn('Error al verificar estado de conexión TRON:', statusError);\n      // Continuar de todos modos, intentaremos con el endpoint simplificado\n    }\n\n    // Intentar primero con el endpoint simplificado que es más robusto\n    try {\n      console.log('Intentando verificación simplificada...');\n      const simpleResponse = await apiClient.get(`/verify/simple/${wallet}`);\n      console.log('Verificación simplificada exitosa');\n      return simpleResponse.data;\n    } catch (simpleError) {\n      var _simpleError$response;\n      console.warn('Error en verificación simplificada:', simpleError);\n\n      // Si es un error 403 (sin tokens), no intentar con el método estándar\n      if (((_simpleError$response = simpleError.response) === null || _simpleError$response === void 0 ? void 0 : _simpleError$response.status) === 403) {\n        throw simpleError;\n      }\n      console.log('Intentando método estándar como fallback...');\n    }\n\n    // Método estándar como fallback\n    const response = await apiClient.get(`/verify/${wallet}`);\n    console.log('Verificación estándar exitosa');\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response2, _error$response3, _error$response3$data;\n    console.error('Error en verificación completa:', error);\n\n    // Mejorar el mensaje de error para el usuario\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 403) {\n      const errorData = error.response.data;\n      throw new Error(errorData.message || 'No tienes tokens suficientes para realizar esta consulta');\n    } else if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) {\n      throw new Error('Has alcanzado el límite de consultas. Por favor, espera antes de intentar nuevamente.');\n    } else if ((_error$response3 = error.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && _error$response3$data.error) {\n      throw new Error(error.response.data.error);\n    } else if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      throw new Error('Error de conexión con el servidor. Por favor, verifica tu conexión a internet e intenta nuevamente.');\n    } else if (error.code === 'ECONNABORTED') {\n      throw new Error('La consulta tardó demasiado tiempo. Por favor, intenta nuevamente.');\n    }\n    throw new Error('Error inesperado al verificar la wallet. Por favor, intenta nuevamente.');\n  }\n};\n\n// Verificación detallada de wallet (consume 1 token, requiere plan pagado)\nexport const verifyWalletDetailed = async wallet => {\n  try {\n    const response = await apiClient.get(`/verify/${wallet}/detailed`);\n    return response.data;\n  } catch (error) {\n    console.error('Error en verificación detallada:', error);\n    throw error;\n  }\n};\n\n// Obtener información del usuario\nexport const getUserInfo = async wallet => {\n  try {\n    const cacheKey = `user_${wallet}`;\n    const response = await apiClient.get(`/users/info/${wallet}`);\n\n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.user) {\n      // Guardar en localStorage para acceso offline\n      saveToLocalStorage(cacheKey, response.data.user);\n      return response.data.user;\n    } else {\n      console.warn('La respuesta de getUserInfo no tiene la estructura esperada:', response.data);\n\n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para el usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, crear un usuario por defecto\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      saveToLocalStorage(cacheKey, defaultUser);\n      return defaultUser;\n    }\n  } catch (error) {\n    console.error('Error al obtener información del usuario:', error);\n\n    // Si es un error de red, intentar usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cacheKey = `user_${wallet}`;\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para el usuario');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, crear un usuario por defecto\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      saveToLocalStorage(cacheKey, defaultUser);\n      return defaultUser;\n    }\n    throw error;\n  }\n};\n\n// Verificar si un usuario existe\nexport const checkUserExists = async wallet => {\n  try {\n    const response = await apiClient.get(`/users/check/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al verificar usuario:', error);\n\n    // Si es un error de red, asumir que el usuario existe para permitir la conexión\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, asumiendo que el usuario existe');\n      return {\n        exists: true,\n        message: 'Backend no disponible, usando modo offline'\n      };\n    }\n    throw error;\n  }\n};\n\n// Registrar un nuevo usuario\nexport const registerUser = async (wallet, username) => {\n  try {\n    const response = await apiClient.post('/users/register', {\n      wallet,\n      username\n    });\n\n    // Si el registro es exitoso, guardar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const defaultUser = {\n        usuario: wallet,\n        username: username,\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      saveToLocalStorage(`user_${wallet}`, defaultUser);\n    }\n    return response.data;\n  } catch (error) {\n    console.error('Error al registrar usuario:', error);\n\n    // Si es un error de red, simular registro exitoso\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando registro exitoso');\n      const defaultUser = {\n        usuario: wallet,\n        username: username,\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      saveToLocalStorage(`user_${wallet}`, defaultUser);\n      return {\n        success: true,\n        message: 'Usuario registrado en modo offline',\n        _offline: true\n      };\n    }\n    throw error;\n  }\n};\n\n// Actualizar el plan del usuario\nexport const updateUserPlan = async (wallet, plan, tokens, subscriptionExpires) => {\n  try {\n    const response = await apiClient.post('/users/update-plan', {\n      wallet,\n      plan,\n      tokens,\n      subscription_expires: subscriptionExpires\n    });\n\n    // Si la actualización es exitosa, actualizar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser) {\n        cachedUser.plan = plan;\n        cachedUser.tokens_disponibles = tokens;\n        cachedUser.expira = subscriptionExpires;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n    }\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar plan:', error);\n\n    // Si es un error de red, simular actualización exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando actualización de plan exitosa');\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser) {\n        cachedUser.plan = plan;\n        cachedUser.tokens_disponibles = tokens;\n        cachedUser.expira = subscriptionExpires;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n      return {\n        success: true,\n        message: 'Plan actualizado en modo offline',\n        _offline: true\n      };\n    }\n    throw error;\n  }\n};\n\n// Consumir token del usuario\nexport const consumeUserToken = async wallet => {\n  try {\n    const response = await apiClient.post('/users/consume-token', {\n      wallet\n    });\n\n    // Si el consumo es exitoso, actualizar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser && cachedUser.tokens_disponibles > 0) {\n        cachedUser.tokens_disponibles -= 1;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n    }\n    return response.data;\n  } catch (error) {\n    console.error('Error al consumir token:', error);\n\n    // Si es un error de red, simular consumo exitoso\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando consumo de token exitoso');\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser && cachedUser.tokens_disponibles > 0) {\n        cachedUser.tokens_disponibles -= 1;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n        return {\n          success: true,\n          tokens_remaining: cachedUser.tokens_disponibles,\n          message: 'Token consumido en modo offline',\n          _offline: true\n        };\n      } else {\n        return {\n          success: false,\n          message: 'No tienes tokens disponibles',\n          _offline: true\n        };\n      }\n    }\n    throw error;\n  }\n};\n\n// Obtener planes disponibles\nexport const getAvailablePlans = async () => {\n  try {\n    const response = await apiClient.get('/users/plans/available');\n\n    // Guardar en caché\n    saveToLocalStorage('available_plans', response.data);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener planes disponibles:', error);\n\n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage('available_plans');\n      if (cachedData) {\n        console.log('Usando datos en caché para planes disponibles');\n        return cachedData;\n      }\n\n      // Si no hay datos en caché, usar planes por defecto\n      const defaultPlans = {\n        success: true,\n        plans: [{\n          id: 'basic',\n          name: 'Basic',\n          price: 9.99,\n          tokens: 100,\n          duration_days: 30\n        }, {\n          id: 'premium',\n          name: 'Premium',\n          price: 19.99,\n          tokens: 300,\n          duration_days: 30\n        }, {\n          id: 'unlimited',\n          name: 'Unlimited',\n          price: 49.99,\n          tokens: Infinity,\n          duration_days: 30\n        }]\n      };\n      saveToLocalStorage('available_plans', defaultPlans);\n      return defaultPlans;\n    }\n    throw error;\n  }\n};\n\n// Crear orden de pago\nexport const createPayment = async (planType, wallet) => {\n  try {\n    const response = await apiClient.post('/payments/create', {\n      planType,\n      wallet\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear orden de pago:', error);\n    throw error;\n  }\n};\n\n// Verificar estado de pago\nexport const checkPaymentStatus = async paymentId => {\n  try {\n    const response = await apiClient.get(`/payments/${paymentId}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al verificar estado de pago:', error);\n    throw error;\n  }\n};\n\n// Generar informe de wallet\nexport const generateWalletReport = async (wallet, format = 'json') => {\n  try {\n    const response = await apiClient.get(`/reports/${wallet}?format=${format}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al generar informe:', error);\n    throw error;\n  }\n};\n\n// Generar informe para Telegram\nexport const generateTelegramReport = async wallet => {\n  try {\n    const response = await apiClient.get(`/reports/${wallet}/telegram`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al generar informe para Telegram:', error);\n    throw error;\n  }\n};\n\n// Obtener configuración de TronGrid API\nexport const getTronGridConfig = async () => {\n  try {\n    const response = await apiClient.get('/config/trongrid');\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener configuración de TronGrid:', error);\n    throw error;\n  }\n};\n\n// ADMIN API - Solo accesible para la wallet de administrador\nconst ADMIN_WALLET = 'TJF7BrGJREfNFjBoCVdSNQyLw1PV5s37hm';\n\n// Verificar si la wallet es de administrador\nexport const isAdminWallet = wallet => {\n  return wallet === ADMIN_WALLET;\n};\n\n// Obtener estadísticas del dashboard (solo admin)\nexport const getAdminDashboardStats = async wallet => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.get('/admin/dashboard', {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de usuarios (solo admin)\nexport const getAdminUsers = async wallet => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.get('/admin/users', {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de usuarios:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de pagos (solo admin)\nexport const getAdminPayments = async wallet => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.get('/admin/payments', {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de pagos:', error);\n    throw error;\n  }\n};\n\n// Actualizar configuración del sistema (solo admin)\nexport const updateSystemSettings = async (wallet, settings) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.put('/admin/settings', settings, {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar configuración del sistema:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de revendedores (solo admin)\nexport const getAdminResellers = async wallet => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.get('/admin/resellers', {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de revendedores:', error);\n    throw error;\n  }\n};\n\n// Crear un nuevo revendedor (solo admin)\nexport const createReseller = async (wallet, resellerData) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.post('/admin/resellers', resellerData, {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear revendedor:', error);\n    throw error;\n  }\n};\n\n// Actualizar cuota de un revendedor (solo admin)\nexport const updateResellerQuota = async (wallet, resellerWallet, newQuota) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  try {\n    const response = await apiClient.put(`/admin/resellers/${resellerWallet}/quota`, {\n      newQuota\n    }, {\n      headers: {\n        'X-Admin-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar cuota de revendedor:', error);\n    throw error;\n  }\n};\n\n// RESELLER API - Solo accesible para revendedores autorizados\n\n// Obtener información del revendedor\nexport const getResellerInfo = async wallet => {\n  try {\n    const response = await apiClient.get('/resellers/info', {\n      headers: {\n        'X-Reseller-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener información de revendedor:', error);\n    throw error;\n  }\n};\n\n// Aplicar descuento a un cliente\nexport const applyResellerDiscount = async (resellerWallet, customerWallet, planType) => {\n  try {\n    const response = await apiClient.post('/resellers/discount', {\n      customerWallet,\n      planType\n    }, {\n      headers: {\n        'X-Reseller-Wallet': resellerWallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al aplicar descuento:', error);\n    throw error;\n  }\n};\n\n// Obtener estadísticas del revendedor\nexport const getResellerStats = async wallet => {\n  try {\n    const response = await apiClient.get('/resellers/stats', {\n      headers: {\n        'X-Reseller-Wallet': wallet\n      }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener estadísticas de revendedor:', error);\n    throw error;\n  }\n};\n\n// ===== FUNCIONES P2P =====\n\n// Obtener ofertas P2P por país\nexport const getP2POffers = async (country, filters = {}) => {\n  try {\n    const response = await apiClient.get(`/p2p/offers/country/${country}`, {\n      params: filters\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener ofertas P2P:', error);\n    throw error;\n  }\n};\n\n// Crear nueva oferta P2P\nexport const createP2POffer = async offerData => {\n  try {\n    const response = await apiClient.post('/p2p/offers', offerData);\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear oferta P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener países disponibles para P2P\nexport const getP2PCountries = async () => {\n  try {\n    const response = await apiClient.get('/p2p/countries');\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener países P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener bancos por país\nexport const getBanksByCountry = async countryCode => {\n  try {\n    const response = await apiClient.get(`/p2p/countries/${countryCode}/banks`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener bancos por país:', error);\n    throw error;\n  }\n};\n\n// Crear orden P2P\nexport const createP2POrder = async orderData => {\n  try {\n    const response = await apiClient.post('/p2p/orders', orderData);\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear orden P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener órdenes P2P del usuario\nexport const getUserP2POrders = async wallet => {\n  try {\n    const response = await apiClient.get(`/p2p/orders/user/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener órdenes P2P del usuario:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de orden P2P\nexport const updateP2POrderStatus = async (orderId, status, data = {}) => {\n  try {\n    const response = await apiClient.put(`/p2p/orders/${orderId}/status`, {\n      status,\n      ...data\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar estado de orden P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener chat de orden P2P\nexport const getP2POrderChat = async orderId => {\n  try {\n    const response = await apiClient.get(`/p2p/orders/${orderId}/chat`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener chat de orden P2P:', error);\n    throw error;\n  }\n};\n\n// Enviar mensaje en chat P2P\nexport const sendP2PChatMessage = async (orderId, message) => {\n  try {\n    const response = await apiClient.post(`/p2p/orders/${orderId}/chat`, {\n      message\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al enviar mensaje en chat P2P:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","apiClient","create","baseURL","headers","timeout","interceptors","response","use","error","message","code","console","warn","Promise","reject","saveToLocalStorage","key","data","localStorage","setItem","JSON","stringify","getFromLocalStorage","defaultValue","getItem","parse","verifyWalletBasic","wallet","get","verifyWallet","log","statusResponse","success","statusError","simpleResponse","simpleError","_simpleError$response","status","_error$response","_error$response2","_error$response3","_error$response3$data","errorData","Error","verifyWalletDetailed","getUserInfo","cacheKey","user","cachedData","defaultUser","usuario","username","substring","tokens_disponibles","plan","expira","checkUserExists","exists","registerUser","post","_offline","updateUserPlan","tokens","subscriptionExpires","subscription_expires","cachedUser","consumeUserToken","tokens_remaining","getAvailablePlans","defaultPlans","plans","id","name","price","duration_days","Infinity","createPayment","planType","checkPaymentStatus","paymentId","generateWalletReport","format","generateTelegramReport","getTronGridConfig","ADMIN_WALLET","isAdminWallet","getAdminDashboardStats","getAdminUsers","getAdminPayments","updateSystemSettings","settings","put","getAdminResellers","createReseller","resellerData","updateResellerQuota","resellerWallet","newQuota","getResellerInfo","applyResellerDiscount","customerWallet","getResellerStats","getP2POffers","country","filters","params","createP2POffer","offerData","getP2PCountries","getBanksByCountry","countryCode","createP2POrder","orderData","getUserP2POrders","updateP2POrderStatus","orderId","getP2POrderChat","sendP2PChatMessage"],"sources":["/Volumes/DATOS/verificador/verificadortrx/frontend/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\n// Configuración de la URL de la API\n// Usar la variable de entorno REACT_APP_API_URL si está definida, de lo contrario usar la URL por defecto\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5173/api';\n\n// Cliente axios con configuración base\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  timeout: 30000, // 30 segundos de timeout para consultas blockchain\n});\n\n// Interceptor para manejar errores de red\napiClient.interceptors.response.use(\n  response => response,\n  error => {\n    // Manejar errores de red\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.warn('Error de conexión a la API. Verificando si hay datos en caché...');\n      \n      // Aquí podríamos implementar una lógica más avanzada para manejar errores de red\n      // Por ahora, simplemente propagamos el error\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// Función para guardar datos en localStorage\nconst saveToLocalStorage = (key, data) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.error('Error guardando en localStorage:', error);\n  }\n};\n\n// Función para obtener datos de localStorage\nconst getFromLocalStorage = (key, defaultValue = null) => {\n  try {\n    const data = localStorage.getItem(key);\n    return data ? JSON.parse(data) : defaultValue;\n  } catch (error) {\n    console.error('Error leyendo de localStorage:', error);\n    return defaultValue;\n  }\n};\n\n// Verificación básica de wallet (sin consumir token)\nexport const verifyWalletBasic = async (wallet) => {\n  try {\n    const response = await apiClient.get(`/verify/basic/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error en verificación básica:', error);\n    throw error;\n  }\n};\n\n// Verificación completa de wallet (consume 1 token)\nexport const verifyWallet = async (wallet) => {\n  try {\n    console.log(`Iniciando verificación de wallet: ${wallet}`);\n    \n    // Primero verificar el estado de la conexión con TRON\n    try {\n      const statusResponse = await apiClient.get('/verify/status');\n      console.log('Estado de conexión TRON:', statusResponse.data);\n      if (!statusResponse.data.success) {\n        console.warn('La conexión con TRON no está disponible, intentando con método alternativo');\n      }\n    } catch (statusError) {\n      console.warn('Error al verificar estado de conexión TRON:', statusError);\n      // Continuar de todos modos, intentaremos con el endpoint simplificado\n    }\n    \n    // Intentar primero con el endpoint simplificado que es más robusto\n    try {\n      console.log('Intentando verificación simplificada...');\n      const simpleResponse = await apiClient.get(`/verify/simple/${wallet}`);\n      console.log('Verificación simplificada exitosa');\n      return simpleResponse.data;\n    } catch (simpleError) {\n      console.warn('Error en verificación simplificada:', simpleError);\n      \n      // Si es un error 403 (sin tokens), no intentar con el método estándar\n      if (simpleError.response?.status === 403) {\n        throw simpleError;\n      }\n      \n      console.log('Intentando método estándar como fallback...');\n    }\n    \n    // Método estándar como fallback\n    const response = await apiClient.get(`/verify/${wallet}`);\n    console.log('Verificación estándar exitosa');\n    return response.data;\n  } catch (error) {\n    console.error('Error en verificación completa:', error);\n    \n    // Mejorar el mensaje de error para el usuario\n    if (error.response?.status === 403) {\n      const errorData = error.response.data;\n      throw new Error(errorData.message || 'No tienes tokens suficientes para realizar esta consulta');\n    } else if (error.response?.status === 429) {\n      throw new Error('Has alcanzado el límite de consultas. Por favor, espera antes de intentar nuevamente.');\n    } else if (error.response?.data?.error) {\n      throw new Error(error.response.data.error);\n    } else if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      throw new Error('Error de conexión con el servidor. Por favor, verifica tu conexión a internet e intenta nuevamente.');\n    } else if (error.code === 'ECONNABORTED') {\n      throw new Error('La consulta tardó demasiado tiempo. Por favor, intenta nuevamente.');\n    }\n    \n    throw new Error('Error inesperado al verificar la wallet. Por favor, intenta nuevamente.');\n  }\n};\n\n// Verificación detallada de wallet (consume 1 token, requiere plan pagado)\nexport const verifyWalletDetailed = async (wallet) => {\n  try {\n    const response = await apiClient.get(`/verify/${wallet}/detailed`);\n    return response.data;\n  } catch (error) {\n    console.error('Error en verificación detallada:', error);\n    throw error;\n  }\n};\n\n// Obtener información del usuario\nexport const getUserInfo = async (wallet) => {\n  try {\n    const cacheKey = `user_${wallet}`;\n    \n    const response = await apiClient.get(`/users/info/${wallet}`);\n    \n    // Verificar que la respuesta tenga la estructura esperada\n    if (response.data && response.data.user) {\n      // Guardar en localStorage para acceso offline\n      saveToLocalStorage(cacheKey, response.data.user);\n      return response.data.user;\n    } else {\n      console.warn('La respuesta de getUserInfo no tiene la estructura esperada:', response.data);\n      \n      // Intentar usar datos en caché\n      const cachedData = getFromLocalStorage(cacheKey);\n      if (cachedData) {\n        console.log('Usando datos en caché para el usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, crear un usuario por defecto\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      \n      saveToLocalStorage(cacheKey, defaultUser);\n      return defaultUser;\n    }\n  } catch (error) {\n    console.error('Error al obtener información del usuario:', error);\n    \n    // Si es un error de red, intentar usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cacheKey = `user_${wallet}`;\n      const cachedData = getFromLocalStorage(cacheKey);\n      \n      if (cachedData) {\n        console.log('Usando datos en caché para el usuario');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, crear un usuario por defecto\n      const defaultUser = {\n        usuario: wallet,\n        username: wallet.substring(0, 6) + '...',\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      \n      saveToLocalStorage(cacheKey, defaultUser);\n      return defaultUser;\n    }\n    \n    throw error;\n  }\n};\n\n// Verificar si un usuario existe\nexport const checkUserExists = async (wallet) => {\n  try {\n    const response = await apiClient.get(`/users/check/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al verificar usuario:', error);\n    \n    // Si es un error de red, asumir que el usuario existe para permitir la conexión\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, asumiendo que el usuario existe');\n      return { exists: true, message: 'Backend no disponible, usando modo offline' };\n    }\n    \n    throw error;\n  }\n};\n\n// Registrar un nuevo usuario\nexport const registerUser = async (wallet, username) => {\n  try {\n    const response = await apiClient.post('/users/register', {\n      wallet,\n      username\n    });\n    \n    // Si el registro es exitoso, guardar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const defaultUser = {\n        usuario: wallet,\n        username: username,\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      \n      saveToLocalStorage(`user_${wallet}`, defaultUser);\n    }\n    \n    return response.data;\n  } catch (error) {\n    console.error('Error al registrar usuario:', error);\n    \n    // Si es un error de red, simular registro exitoso\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando registro exitoso');\n      \n      const defaultUser = {\n        usuario: wallet,\n        username: username,\n        tokens_disponibles: 3,\n        plan: 'Free',\n        expira: null\n      };\n      \n      saveToLocalStorage(`user_${wallet}`, defaultUser);\n      \n      return {\n        success: true,\n        message: 'Usuario registrado en modo offline',\n        _offline: true\n      };\n    }\n    \n    throw error;\n  }\n};\n\n// Actualizar el plan del usuario\nexport const updateUserPlan = async (wallet, plan, tokens, subscriptionExpires) => {\n  try {\n    const response = await apiClient.post('/users/update-plan', {\n      wallet,\n      plan,\n      tokens,\n      subscription_expires: subscriptionExpires\n    });\n    \n    // Si la actualización es exitosa, actualizar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser) {\n        cachedUser.plan = plan;\n        cachedUser.tokens_disponibles = tokens;\n        cachedUser.expira = subscriptionExpires;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n    }\n    \n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar plan:', error);\n    \n    // Si es un error de red, simular actualización exitosa\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando actualización de plan exitosa');\n      \n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser) {\n        cachedUser.plan = plan;\n        cachedUser.tokens_disponibles = tokens;\n        cachedUser.expira = subscriptionExpires;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n      \n      return {\n        success: true,\n        message: 'Plan actualizado en modo offline',\n        _offline: true\n      };\n    }\n    \n    throw error;\n  }\n};\n\n// Consumir token del usuario\nexport const consumeUserToken = async (wallet) => {\n  try {\n    const response = await apiClient.post('/users/consume-token', {\n      wallet\n    });\n    \n    // Si el consumo es exitoso, actualizar el usuario en localStorage\n    if (response.data && response.data.success) {\n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser && cachedUser.tokens_disponibles > 0) {\n        cachedUser.tokens_disponibles -= 1;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n      }\n    }\n    \n    return response.data;\n  } catch (error) {\n    console.error('Error al consumir token:', error);\n    \n    // Si es un error de red, simular consumo exitoso\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      console.log('Backend no disponible, simulando consumo de token exitoso');\n      \n      const cachedUser = getFromLocalStorage(`user_${wallet}`);\n      if (cachedUser && cachedUser.tokens_disponibles > 0) {\n        cachedUser.tokens_disponibles -= 1;\n        saveToLocalStorage(`user_${wallet}`, cachedUser);\n        \n        return {\n          success: true,\n          tokens_remaining: cachedUser.tokens_disponibles,\n          message: 'Token consumido en modo offline',\n          _offline: true\n        };\n      } else {\n        return {\n          success: false,\n          message: 'No tienes tokens disponibles',\n          _offline: true\n        };\n      }\n    }\n    \n    throw error;\n  }\n};\n\n// Obtener planes disponibles\nexport const getAvailablePlans = async () => {\n  try {\n    const response = await apiClient.get('/users/plans/available');\n    \n    // Guardar en caché\n    saveToLocalStorage('available_plans', response.data);\n    \n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener planes disponibles:', error);\n    \n    // Si es un error de red, usar datos en caché\n    if (error.message === 'Network Error' || error.code === 'ERR_NETWORK') {\n      const cachedData = getFromLocalStorage('available_plans');\n      if (cachedData) {\n        console.log('Usando datos en caché para planes disponibles');\n        return cachedData;\n      }\n      \n      // Si no hay datos en caché, usar planes por defecto\n      const defaultPlans = {\n        success: true,\n        plans: [\n          { id: 'basic', name: 'Basic', price: 9.99, tokens: 100, duration_days: 30 },\n          { id: 'premium', name: 'Premium', price: 19.99, tokens: 300, duration_days: 30 },\n          { id: 'unlimited', name: 'Unlimited', price: 49.99, tokens: Infinity, duration_days: 30 }\n        ]\n      };\n      \n      saveToLocalStorage('available_plans', defaultPlans);\n      return defaultPlans;\n    }\n    \n    throw error;\n  }\n};\n\n// Crear orden de pago\nexport const createPayment = async (planType, wallet) => {\n  try {\n    const response = await apiClient.post('/payments/create', { planType, wallet });\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear orden de pago:', error);\n    throw error;\n  }\n};\n\n// Verificar estado de pago\nexport const checkPaymentStatus = async (paymentId) => {\n  try {\n    const response = await apiClient.get(`/payments/${paymentId}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al verificar estado de pago:', error);\n    throw error;\n  }\n};\n\n// Generar informe de wallet\nexport const generateWalletReport = async (wallet, format = 'json') => {\n  try {\n    const response = await apiClient.get(`/reports/${wallet}?format=${format}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al generar informe:', error);\n    throw error;\n  }\n};\n\n// Generar informe para Telegram\nexport const generateTelegramReport = async (wallet) => {\n  try {\n    const response = await apiClient.get(`/reports/${wallet}/telegram`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al generar informe para Telegram:', error);\n    throw error;\n  }\n};\n\n// Obtener configuración de TronGrid API\nexport const getTronGridConfig = async () => {\n  try {\n    const response = await apiClient.get('/config/trongrid');\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener configuración de TronGrid:', error);\n    throw error;\n  }\n};\n\n// ADMIN API - Solo accesible para la wallet de administrador\nconst ADMIN_WALLET = 'TJF7BrGJREfNFjBoCVdSNQyLw1PV5s37hm';\n\n// Verificar si la wallet es de administrador\nexport const isAdminWallet = (wallet) => {\n  return wallet === ADMIN_WALLET;\n};\n\n// Obtener estadísticas del dashboard (solo admin)\nexport const getAdminDashboardStats = async (wallet) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.get('/admin/dashboard', {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de usuarios (solo admin)\nexport const getAdminUsers = async (wallet) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.get('/admin/users', {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de usuarios:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de pagos (solo admin)\nexport const getAdminPayments = async (wallet) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.get('/admin/payments', {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de pagos:', error);\n    throw error;\n  }\n};\n\n// Actualizar configuración del sistema (solo admin)\nexport const updateSystemSettings = async (wallet, settings) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.put('/admin/settings', settings, {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar configuración del sistema:', error);\n    throw error;\n  }\n};\n\n// Obtener lista de revendedores (solo admin)\nexport const getAdminResellers = async (wallet) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.get('/admin/resellers', {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener lista de revendedores:', error);\n    throw error;\n  }\n};\n\n// Crear un nuevo revendedor (solo admin)\nexport const createReseller = async (wallet, resellerData) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.post('/admin/resellers', resellerData, {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear revendedor:', error);\n    throw error;\n  }\n};\n\n// Actualizar cuota de un revendedor (solo admin)\nexport const updateResellerQuota = async (wallet, resellerWallet, newQuota) => {\n  if (!isAdminWallet(wallet)) {\n    throw new Error('Acceso denegado: No eres administrador');\n  }\n  \n  try {\n    const response = await apiClient.put(`/admin/resellers/${resellerWallet}/quota`, { newQuota }, {\n      headers: { 'X-Admin-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar cuota de revendedor:', error);\n    throw error;\n  }\n};\n\n// RESELLER API - Solo accesible para revendedores autorizados\n\n// Obtener información del revendedor\nexport const getResellerInfo = async (wallet) => {\n  try {\n    const response = await apiClient.get('/resellers/info', {\n      headers: { 'X-Reseller-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener información de revendedor:', error);\n    throw error;\n  }\n};\n\n// Aplicar descuento a un cliente\nexport const applyResellerDiscount = async (resellerWallet, customerWallet, planType) => {\n  try {\n    const response = await apiClient.post('/resellers/discount', \n      { customerWallet, planType },\n      { headers: { 'X-Reseller-Wallet': resellerWallet } }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error al aplicar descuento:', error);\n    throw error;\n  }\n};\n\n// Obtener estadísticas del revendedor\nexport const getResellerStats = async (wallet) => {\n  try {\n    const response = await apiClient.get('/resellers/stats', {\n      headers: { 'X-Reseller-Wallet': wallet }\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener estadísticas de revendedor:', error);\n    throw error;\n  }\n};\n\n// ===== FUNCIONES P2P =====\n\n// Obtener ofertas P2P por país\nexport const getP2POffers = async (country, filters = {}) => {\n  try {\n    const response = await apiClient.get(`/p2p/offers/country/${country}`, {\n      params: filters\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener ofertas P2P:', error);\n    throw error;\n  }\n};\n\n// Crear nueva oferta P2P\nexport const createP2POffer = async (offerData) => {\n  try {\n    const response = await apiClient.post('/p2p/offers', offerData);\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear oferta P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener países disponibles para P2P\nexport const getP2PCountries = async () => {\n  try {\n    const response = await apiClient.get('/p2p/countries');\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener países P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener bancos por país\nexport const getBanksByCountry = async (countryCode) => {\n  try {\n    const response = await apiClient.get(`/p2p/countries/${countryCode}/banks`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener bancos por país:', error);\n    throw error;\n  }\n};\n\n// Crear orden P2P\nexport const createP2POrder = async (orderData) => {\n  try {\n    const response = await apiClient.post('/p2p/orders', orderData);\n    return response.data;\n  } catch (error) {\n    console.error('Error al crear orden P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener órdenes P2P del usuario\nexport const getUserP2POrders = async (wallet) => {\n  try {\n    const response = await apiClient.get(`/p2p/orders/user/${wallet}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener órdenes P2P del usuario:', error);\n    throw error;\n  }\n};\n\n// Actualizar estado de orden P2P\nexport const updateP2POrderStatus = async (orderId, status, data = {}) => {\n  try {\n    const response = await apiClient.put(`/p2p/orders/${orderId}/status`, {\n      status,\n      ...data\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al actualizar estado de orden P2P:', error);\n    throw error;\n  }\n};\n\n// Obtener chat de orden P2P\nexport const getP2POrderChat = async (orderId) => {\n  try {\n    const response = await apiClient.get(`/p2p/orders/${orderId}/chat`);\n    return response.data;\n  } catch (error) {\n    console.error('Error al obtener chat de orden P2P:', error);\n    throw error;\n  }\n};\n\n// Enviar mensaje en chat P2P\nexport const sendP2PChatMessage = async (orderId, message) => {\n  try {\n    const response = await apiClient.post(`/p2p/orders/${orderId}/chat`, {\n      message\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error al enviar mensaje en chat P2P:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}